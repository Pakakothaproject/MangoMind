-- =================================================================
-- DATABASE SCHEMA FOR AI APP
-- =================================================================
--
-- WORKING SETUP (as of Oct 23, 2025):
-- - Models are stored in 'models' table with is_active, is_free_tier flags
-- - Subscription packages are in 'subscription_packages' with enabled_models array
-- - User profiles link to packages via current_package_id and package_expires_at
-- - Model access is determined by frontend override in configService.ts
-- - The SQL function get_my_enabled_models() may return incorrect is_accessible flags
-- - Frontend corrects this by checking actual package data and overriding flags
--
-- KEY TABLES:
-- - models: All AI models with metadata and flags
-- - subscription_packages: Package definitions with enabled_models arrays
-- - profiles: User data with current_package_id and expiration
--
-- =================================================================
-- Create a table for public user profiles if it doesn't exist
create table if not exists profiles (
  id uuid not null references auth.users on delete cascade,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,
  gender text,
  birth_date date,
  username_last_changed_at timestamp with time zone,
  user_preferences jsonb,
  token_balance bigint not null default 0,
  current_package_id integer,
  package_expires_at timestamp with time zone,
  free_generations_remaining smallint not null default 0,
  bonus_expires_at timestamptz,
  storage_limit_bytes bigint not null default 209715200, -- 200 MB

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

-- Add columns that might be missing from older versions of the table
alter table profiles add column if not exists gender text;
alter table profiles add column if not exists birth_date date;
alter table profiles add column if not exists username_last_changed_at timestamp with time zone;
alter table profiles add column if not exists user_preferences jsonb;
-- New columns for subscriptions and token management
alter table profiles add column if not exists token_balance bigint not null default 0;
alter table profiles add column if not exists current_package_id integer; -- Will be FK after table creation
alter table profiles add column if not exists package_expires_at timestamp with time zone;
alter table profiles add column if not exists free_generations_remaining smallint not null default 0;
alter table profiles add column if not exists bonus_expires_at timestamptz;
alter table profiles add column if not exists storage_limit_bytes bigint not null default 209715200; -- 200 MB


-- Enable Row Level Security
alter table profiles
  enable row level security;

-- Drop existing policies before creating them to avoid errors on re-run
drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Authenticated users can view all profiles." on profiles;
drop policy if exists "Users can view their own profile." on profiles;
drop policy if exists "Users can insert their own profile." on profiles;
drop policy if exists "Users can update own profile." on profiles;
drop policy if exists "Users can manage their own profile." on profiles;

-- Consolidated policy for profiles
create policy "Users can manage their own profile." on profiles
  for all to authenticated
  using (auth.uid() = id)
  with check (auth.uid() = id);


-- This trigger automatically creates a profile entry when a new user signs up
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
    user_username text;
begin
  -- Extract username from user metadata, fallback to email prefix if not available
  -- For Google OAuth, username might not be available, so we generate one
  user_username := new.raw_user_meta_data->>'username';

  -- If no username in metadata, try to create one from email
  if user_username is null then
    user_username := split_part(new.email, '@', 1);
  end if;

  -- If still no username (shouldn't happen), create a fallback
  if user_username is null or user_username = '' then
    user_username := 'user_' || substr(new.id::text, 1, 8);
  end if;

  -- Ensure username is unique by appending numbers if needed
  declare
    counter integer := 0;
    final_username text := user_username;
  begin
    while exists(select 1 from public.profiles where username = final_username) loop
      counter := counter + 1;
      final_username := user_username || counter::text;
    end loop;
    user_username := final_username;
  end;

  insert into public.profiles (id, username, token_balance, free_generations_remaining, bonus_expires_at, storage_limit_bytes)
  values (new.id, user_username, 10000, 3, now() + interval '2 days', 209715200); -- 200MB default

  -- Add default categories for new user
  insert into public.categories (user_id, name)
  values (new.id, 'Work'), (new.id, 'Personal');

  -- Add default personas for new user
  insert into public.personas (user_id, name, icon, system_prompt)
  values
    (new.id, 'Doctor', 'medical_services', 'You are a helpful and empathetic medical professional. Provide information for educational purposes, but always remind the user to consult a real doctor for medical advice.'),
    (new.id, 'Friend', 'sentiment_satisfied', 'You are a friendly and supportive companion. Chat in a casual, conversational tone.'),
    (new.id, 'Lawyer', 'gavel', 'You are a knowledgeable and professional lawyer. Provide general legal information and explanations for educational purposes, but always state that you are not giving legal advice and the user should consult with a licensed attorney for their specific situation.'),
    (new.id, 'Rabindranath Tagore', 'history_edu', 'You are the spirit of Rabindranath Tagore, the great Bengali poet, philosopher, and artist. Respond with wisdom, poetic language, and a deep appreciation for nature, humanity, and art. Your tone should be gentle, profound, and reflective.')
  on conflict (user_id, name) do nothing;

  return new;
end;
$$;

-- Drop existing trigger before creating it to avoid errors on re-run
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Function to backfill default categories and personas for existing users
create or replace function public.backfill_user_defaults(p_user_id uuid)
returns void as $$
begin
    -- Backfill default categories if none exist for the user
    if not exists (select 1 from public.categories where user_id = p_user_id) then
        insert into public.categories (user_id, name)
        values (p_user_id, 'Work'), (p_user_id, 'Personal');
    end if;

    -- Backfill default personas for existing users, checking for existence individually to avoid ON CONFLICT issues.
    insert into public.personas (user_id, name, icon, system_prompt)
    select p_user_id, 'Doctor', 'medical_services', 'You are a helpful and empathetic medical professional. Provide information for educational purposes, but always remind the user to consult a real doctor for medical advice.'
    where not exists (select 1 from public.personas where user_id = p_user_id and name = 'Doctor');

    insert into public.personas (user_id, name, icon, system_prompt)
    select p_user_id, 'Friend', 'sentiment_satisfied', 'You are a friendly and supportive companion. Chat in a casual, conversational tone.'
    where not exists (select 1 from public.personas where user_id = p_user_id and name = 'Friend');

    insert into public.personas (user_id, name, icon, system_prompt)
    select p_user_id, 'Lawyer', 'gavel', 'You are a knowledgeable and professional lawyer. Provide general legal information and explanations for educational purposes, but always state that you are not giving legal advice and the user should consult with a licensed attorney for their specific situation.'
    where not exists (select 1 from public.personas where user_id = p_user_id and name = 'Lawyer');
    
    insert into public.personas (user_id, name, icon, system_prompt)
    select p_user_id, 'Rabindranath Tagore', 'history_edu', 'You are the spirit of Rabindranath Tagore, the great Bengali poet, philosopher, and artist. Respond with wisdom, poetic language, and a deep appreciation for nature, humanity, and art. Your tone should be gentle, profound, and reflective.'
    where not exists (select 1 from public.personas where user_id = p_user_id and name = 'Rabindranath Tagore');
end;
$$ language plpgsql;

-- Set up Storage!
insert into storage.buckets (id, name, public)
  values ('avatars', 'avatars', true)
  on conflict (id) do nothing;

-- Set up security policies for storage
drop policy if exists "Avatar images are publicly accessible." on storage.objects;
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

drop policy if exists "Anyone can upload an avatar." on storage.objects;
create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

drop policy if exists "Anyone can update their own avatar." on storage.objects;
create policy "Anyone can update their own avatar." on storage.objects
  for update using (auth.uid() = owner) with check (bucket_id = 'avatars');

-- Create table for user generations
create table if not exists generations (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  image_url text not null,
  prompt text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for generations table
alter table generations enable row level security;

-- Add columns that might be missing from older versions of the table to fix potential schema mismatch
alter table generations add column if not exists type text;
alter table generations add column if not exists model_used text;
alter table generations add column if not exists api_provider text;
alter table generations add column if not exists settings jsonb;
alter table generations add column if not exists size_bytes integer;

-- Policies for generations table
drop policy if exists "Authenticated users can view all generations." on generations;
drop policy if exists "Public generations are viewable by everyone." on generations;
drop policy if exists "Users can view their own generations." on generations;
drop policy if exists "Users can insert their own generations." on generations;
drop policy if exists "Users can delete their own generations." on generations;
drop policy if exists "Users can manage their own generations." on generations;

-- Consolidated policy for generations
create policy "Users can manage their own generations." on generations
  for all to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- Create table for chat history
create table if not exists chats (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text
);

-- Alter chats table to add new columns
alter table chats add column if not exists updated_at timestamp with time zone default timezone('utc'::text, now()) not null;
alter table chats add column if not exists system_instruction text;
alter table chats add column if not exists models text[];
alter table chats add column if not exists category text default 'Uncategorized';
alter table chats add column if not exists pinned boolean default false;
alter table chats add column if not exists chat_mode text default 'normal' not null;


-- Create table for chat messages
create table if not exists messages (
  id bigint generated by default as identity primary key,
  chat_id bigint references chats on delete cascade not null,
  role text not null check (role in ('user', 'model')),
  content text,
  image_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Alter messages table to add new column
alter table messages add column if not exists source_model text;
alter table messages add column if not exists reasoning_data text;

-- Function to update updated_at on chats table
create or replace function public.update_chat_updated_at()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  update public.chats
  set updated_at = timezone('utc'::text, now())
  where id = NEW.chat_id;
  return NEW;
end;
$$;

-- Trigger to call the function
drop trigger if exists on_message_insert on public.messages;
create trigger on_message_insert
  after insert on public.messages
  for each row
  execute procedure public.update_chat_updated_at();

-- Enable RLS for chat tables
alter table chats enable row level security;
alter table messages enable row level security;

-- Policies for chats table
drop policy if exists "Users can view their own chats." on chats;
drop policy if exists "Users can insert their own chats." on chats;
drop policy if exists "Users can update their own chats." on chats;
drop policy if exists "Users can delete their own chats." on chats;
drop policy if exists "Users can manage their own chats." on chats;

-- Consolidated policy for chats
create policy "Users can manage their own chats." on chats
    for all to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

-- Function to get the user_id for a given chat_id, for use in RLS policies.
-- This is more performant than a subquery inside the policy definition.
create or replace function public.get_chat_user_id(p_chat_id bigint)
returns uuid
language sql
stable
security definer
set search_path = public
as $$
  select user_id from public.chats where id = p_chat_id;
$$;
grant execute on function public.get_chat_user_id(bigint) to authenticated;

-- Policies for messages table
drop policy if exists "Users can view their own messages." on messages;
drop policy if exists "Users can insert their own messages." on messages;
drop policy if exists "Users can update their own messages." on messages;
drop policy if exists "Users can delete their own messages." on messages;
drop policy if exists "Users can manage their own messages." on messages;

-- Ensure foreign key from messages to chats has ON DELETE CASCADE
-- This makes sure that when a chat is deleted, all its messages are automatically deleted.
alter table public.messages
    drop constraint if exists messages_chat_id_fkey;

alter table public.messages
    add constraint messages_chat_id_fkey
    foreign key (chat_id) references public.chats(id) on delete cascade;

-- Consolidated policy for messages using the performant function
create policy "Users can manage their own messages." on messages
    for all to authenticated
    using (auth.uid() = public.get_chat_user_id(chat_id))
    with check (auth.uid() = public.get_chat_user_id(chat_id));

-- Create table for user personas
create table if not exists personas (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  icon text not null,
  system_prompt text not null,
  unique(user_id, name)
);

-- Enable RLS for personas table
alter table personas enable row level security;

-- Policies for personas table
drop policy if exists "Users can view their own personas." on personas;
drop policy if exists "Users can insert their own personas." on personas;
drop policy if exists "Users can update their own personas." on personas;
drop policy if exists "Users can delete their own personas." on personas;
drop policy if exists "Users can manage their own personas." on personas;

-- Consolidated policy for personas
create policy "Users can manage their own personas." on personas
    for all to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

-- Create table for user-defined chat categories
create table if not exists categories (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  name text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, name)
);

-- Enable RLS for categories table
alter table categories enable row level security;

-- Policies for categories table
drop policy if exists "Users can view their own categories." on categories;
drop policy if exists "Users can insert their own categories." on categories;
drop policy if exists "Users can update their own categories." on categories;
drop policy if exists "Users can delete their own categories." on categories;
drop policy if exists "Users can manage their own categories." on categories;

-- Consolidated policy for categories
create policy "Users can manage their own categories." on categories
    for all to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

-- New function to check username availability and provide suggestions
create or replace function get_username_status(p_username text)
returns json as $$
declare
  is_taken boolean;
  suggestions text[] := '{}';
  random_adj text[] := array['Cool', 'Happy', 'Quick', 'Sly', 'True', 'Real', 'First', 'Top'];
  adj text;
  num text;
  i integer;
begin
  -- Basic validation
  if char_length(p_username) < 3 then
    return json_build_object('status', 'too_short');
  end if;
  if p_username ~* '[^a-zA-Z0-9_]' then
    return json_build_object('status', 'invalid_chars');
  end if;
  select exists(select 1 from public.profiles where username ilike p_username) into is_taken;
  if is_taken then
    -- Generate suggestions
    for i in 1..3 loop
      -- Suggestion with number
      num := p_username || floor(random() * 90 + 10)::text;
      if not exists(select 1 from public.profiles where username ilike num) then
        suggestions := array_append(suggestions, num);
      end if;
      -- Suggestion with adjective
      adj := random_adj[floor(random() * array_length(random_adj, 1) + 1)::int] || p_username;
      if not exists(select 1 from public.profiles where username ilike adj) then
        suggestions := array_append(suggestions, adj);
      end if;
    end loop;
    return json_build_object('status', 'taken', 'suggestions', array_to_json(suggestions));
  else
    return json_build_object('status', 'available');
  end if;
end;
$$ language plpgsql;

-- New function to update profile with username change restrictions
create or replace function update_user_profile(
    p_username text,
    p_full_name text,
    p_gender text,
    p_birth_date date
)
returns void as $$
declare
    current_profile record;
begin
    select * from public.profiles where id = auth.uid() into current_profile;

    -- Check if username exists if it's being changed
    if current_profile.username is null or current_profile.username ilike p_username = false then
        if exists(select 1 from public.profiles where username ilike p_username and id != auth.uid()) then
            raise exception 'Username is already taken.';
        end if;
    end if;

    -- Check if username is being changed (and it's not the first time it's being set)
    if current_profile.username is not null and current_profile.username ilike p_username = false then
        -- Check if it has been changed in the last 30 days
        if current_profile.username_last_changed_at is not null and current_profile.username_last_changed_at > now() - interval '30 days' then
            raise exception 'Username can only be changed once every 30 days. Last changed on %', to_char(current_profile.username_last_changed_at at time zone 'utc', 'YYYY-MM-DD');
        end if;
        
        -- Update profile and the timestamp
        update public.profiles
        set
            username = p_username,
            full_name = p_full_name,
            gender = p_gender,
            birth_date = p_birth_date,
            updated_at = now(),
            username_last_changed_at = now()
        where id = auth.uid();
    else
        -- Just update other details, or set username for the first time
        update public.profiles
        set
            username = p_username,
            full_name = p_full_name,
            gender = p_gender,
            birth_date = p_birth_date,
            updated_at = now()
        where id = auth.uid();
    end if;
end;
$$ language plpgsql security invoker;

-- Grant execute permission on the new functions to authenticated users
grant execute on function public.get_username_status(text) to authenticated;
grant execute on function public.update_user_profile(text, text, text, date) to authenticated;

-- Create table for token usage
create table if not exists token_usage (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  model_used text,
  feature text,
  input_tokens integer not null default 0,
  output_tokens integer not null default 0,
  total_tokens integer not null default 0,
  cost_usd numeric(10, 6)
);
-- Add cost_usd column if missing for backward compatibility
alter table token_usage add column if not exists cost_usd numeric(10, 6);


-- Enable RLS for token_usage table
alter table token_usage enable row level security;

-- Policies for token_usage table
drop policy if exists "Users can view their own token usage." on token_usage;
create policy "Users can view their own token usage." on token_usage
  for select using (auth.uid() = user_id);

-- This table is now written to by a SECURITY DEFINER function, so no insert policy is needed for users.
drop policy if exists "Users can insert their own token usage." on token_usage;

-- New SECURITY DEFINER function to log usage AND deduct tokens for Gemini/non-Runware tasks
drop function if exists public.consume_resource_and_log(text, text, integer, integer, integer, boolean);
create or replace function consume_resource_and_log(
    p_model_used text,
    p_feature text,
    p_input_tokens integer,
    p_output_tokens integer,
    p_total_tokens integer,
    p_is_image_generation boolean
)
returns void as $$
declare
    current_profile record;
    is_bonus_valid boolean;
    is_package_valid boolean;
    effective_tokens_to_deduct integer;
begin
    select * from public.profiles where id = auth.uid() into current_profile;

    is_bonus_valid := current_profile.bonus_expires_at is not null and current_profile.bonus_expires_at > now();
    is_package_valid := current_profile.package_expires_at is not null and current_profile.package_expires_at > now();

    -- This function now ONLY handles Gemini image gen (with free credits) and text gen.
    -- Runware image gen has its own function.

    -- Handle free Gemini image generation from bonus
    if p_is_image_generation and is_bonus_valid and current_profile.free_generations_remaining > 0 then
        update public.profiles
        set free_generations_remaining = free_generations_remaining - 1
        where id = auth.uid();

        insert into public.token_usage(user_id, model_used, feature, input_tokens, output_tokens, total_tokens)
        values (auth.uid(), p_model_used, p_feature, p_input_tokens, p_output_tokens, 0); -- Log as 0 cost

        return;
    end if;

    -- Handle token deduction for text generation
    effective_tokens_to_deduct := p_total_tokens;
    
    if current_profile.token_balance < effective_tokens_to_deduct then
        raise exception 'Insufficient tokens. You need % tokens, but you only have %. Please purchase a new package.', effective_tokens_to_deduct, current_profile.token_balance;
    end if;
    
    -- Deduct tokens from profile
    update public.profiles
    set token_balance = token_balance - effective_tokens_to_deduct
    where id = auth.uid();

    -- Insert into usage log
    insert into public.token_usage(user_id, model_used, feature, input_tokens, output_tokens, total_tokens)
    values (auth.uid(), p_model_used, p_feature, p_input_tokens, p_output_tokens, effective_tokens_to_deduct);

end;
$$ language plpgsql security definer;

grant execute on function public.consume_resource_and_log(text, text, integer, integer, integer, boolean) to authenticated;

-- Add config for USD to token conversion rate
insert into public.app_config (key, value)
values ('usd_to_tokens_rate', '400000') -- 1 USD = 400,000 tokens (based on $0.0000025 per token)
on conflict (key) do nothing;


-- New function for logging Runware usage and deducting tokens based on USD cost
create or replace function log_runware_usage_and_deduct_tokens(
    p_model_used text,
    p_feature text,
    p_cost_usd numeric
)
returns void as $$
declare
    current_profile record;
    is_bonus_valid boolean;
    tokens_to_deduct integer;
    usd_to_tokens_rate numeric;
begin
    select * from public.profiles where id = auth.uid() into current_profile;
    is_bonus_valid := current_profile.bonus_expires_at is not null and current_profile.bonus_expires_at > now();

    -- Handle free image generation from bonus first
    if is_bonus_valid and current_profile.free_generations_remaining > 0 then
        update public.profiles
        set free_generations_remaining = free_generations_remaining - 1
        where id = auth.uid();

        insert into public.token_usage(user_id, model_used, feature, total_tokens, cost_usd)
        values (auth.uid(), p_model_used, p_feature, 0, p_cost_usd); -- Log as 0 token cost but record USD cost

        return;
    end if;

    -- If no free generations, convert USD cost to tokens and deduct
    select (value->>0)::numeric into usd_to_tokens_rate from public.app_config where key = 'usd_to_tokens_rate';
    if usd_to_tokens_rate is null then
        -- Fallback if not set in config, based on $0.0000025 per token
        usd_to_tokens_rate := 400000;
    end if;

    tokens_to_deduct := ceil(p_cost_usd * usd_to_tokens_rate);

    if current_profile.token_balance < tokens_to_deduct then
        raise exception 'Insufficient tokens. This action costs % tokens, but you only have %. Please purchase a new package.', tokens_to_deduct, current_profile.token_balance;
    end if;

    update public.profiles
    set token_balance = token_balance - tokens_to_deduct
    where id = auth.uid();
    
    insert into public.token_usage(user_id, model_used, feature, total_tokens, cost_usd)
    values (auth.uid(), p_model_used, p_feature, tokens_to_deduct, p_cost_usd);

end;
$$ language plpgsql security definer;

grant execute on function public.log_runware_usage_and_deduct_tokens(text, text, numeric) to authenticated;


-- New RPC to get current token balance for the authenticated user
create or replace function public.get_my_token_balance()
returns bigint as $$
begin
  return (select token_balance from public.profiles where id = auth.uid());
end;
$$ language plpgsql security invoker;

grant execute on function public.get_my_token_balance() to authenticated;


-- New table for global app configuration
create table if not exists app_config (
  key text primary key,
  value jsonb not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table app_config enable row level security;

-- Policies for app_config
drop policy if exists "App config is viewable by everyone." on public.app_config;
-- Everyone can read the config
create policy "App config is viewable by everyone." on public.app_config
  for select using (true);
-- Only service_role can update (no policy for update/insert means only service_role can)

-- Function to get a config value
create or replace function get_app_config(p_key text)
returns jsonb as $$
begin
  return (select value from public.app_config where key = p_key);
end;
$$ language plpgsql security invoker;

grant execute on function public.get_app_config(text) to anon;

-- Create table for models
create table if not exists models (
  id text primary key,
  name text not null,
  category text not null,
  model_type text not null,
  logo_url text,
  tags text[],
  is_active boolean default true not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add free tier flag
alter table models add column if not exists is_free_tier boolean not null default false;
alter table models add column if not exists model_type text not null default 'chat';


-- Enable RLS for models table
alter table models enable row level security;

-- Policies for models table
drop policy if exists "Public can view active models." on models;
create policy "Public can view active models." on models
  for select using (is_active = true);

-- RPC to get all models accessible to the current user
-- NOTE: The frontend now overrides the is_accessible flag based on actual package data
-- This is because the SQL function may not update correctly in Supabase
drop function if exists public.get_my_enabled_models();
create or replace function public.get_my_enabled_models()
returns table (
  id text,
  name text,
  category text,
  model_type text,
  logo_url text,
  tags text[],
  is_active boolean,
  created_at timestamp with time zone,
  is_free_tier boolean,
  is_accessible boolean
)
language sql
security invoker
set search_path = public
as $$
SELECT
  m.id,
  m.name,
  m.category,
  m.model_type,
  m.logo_url,
  m.tags,
  m.is_active,
  m.created_at,
  m.is_free_tier,
  -- NOTE: This is_accessible flag may be overridden by frontend logic
  -- The frontend checks the user's actual package and sets is_accessible accordingly
  (
    m.is_free_tier OR COALESCE((
      SELECT
        (
          sp.enabled_models IS NULL OR
          cardinality(sp.enabled_models) = 0 OR
          m.id = ANY(sp.enabled_models)
        )
      FROM public.profiles p
      JOIN public.subscription_packages sp ON p.current_package_id = sp.id
      WHERE
        p.id = auth.uid() AND
        p.package_expires_at > now()
    ), false)
  )::boolean AS is_accessible
FROM
  public.models m
WHERE
  m.is_active = true
ORDER BY
  m.category, m.name;
$$;
grant execute on function public.get_my_enabled_models() to authenticated;

-- =================================================================
-- NEW SUBSCRIPTION PACKAGE MANAGEMENT SECTION
-- =================================================================
create table if not exists subscription_packages (
    id serial primary key,
    name text not null,
    price numeric(10, 2) not null,
    tokens_granted bigint not null,
    storage_mb integer not null default 200,
    description text,
    enabled_models text[],
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

-- Add storage_mb column if it doesn't exist for backward compatibility with older schemas
alter table subscription_packages add column if not exists storage_mb integer not null default 200;

-- RLS for subscription packages (only admin can access)
alter table subscription_packages enable row level security;
drop policy if exists "Admin can manage subscription packages" on subscription_packages;
-- No policies means only service_role can access. This is secure.

-- Add foreign key constraint from profiles to packages
alter table profiles
drop constraint if exists profiles_current_package_id_fkey;

alter table profiles
add constraint profiles_current_package_id_fkey
foreign key (current_package_id) references subscription_packages(id) on delete set null;